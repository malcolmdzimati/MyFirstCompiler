import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

interface State {
    public State next(Token word, int i);
    String colon=":";
    String symbols="0{}()[],;";
    String smallAlpha="abcdefghijklmnopqrstuvwxyz";
    String bigAlpha="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    String wholeNumbers="0123456789";
    String naturalNumbers="123456789";
    String quotation="\"";
    String blank=" ";
    String assignment="=";
    String negative="-";
}

interface FinalState extends State {
}


enum AcceptingState implements FinalState {
    Accept {
        @Override
        public State next(Token word, int i) {
            return Accept;
        }
    };
}

enum FailingState implements FinalState {
    Fail {
        @Override
        public State next(Token word, int i) {
            return Fail;
        }
    };
}

enum States implements State {
    A {
        @Override
        public State next(Token word, int i) {
            if (word.hasNext()) {
                if(colon.indexOf(word.read(i))!=-1){
                    return B;
                }

                if(symbols.indexOf(word.read(i))!=-1){
                    return C;
                }

                if(smallAlpha.indexOf(word.read(i))!=-1){
                    return D;
                }

                if(quotation.indexOf(word.read(i))!=-1){
                    return E;
                }

                if(naturalNumbers.indexOf(word.read(i))!=-1){
                    return F;
                }

                if(negative.indexOf(word.read(i))!=-1){
                    return G;
                }
            }
            return FailingState.Fail;
        }
    },

    B {
        @Override
        public State next(Token word, int i) {
            if (word.hasNext()) {
                if(assignment.indexOf(word.read(i))!=-1){
                    return C;
                }
            }
            return FailingState.Fail;
        }
    },

    C {
        @Override
        public State next(Token word, int i) {
            return AcceptingState.Accept;
        }
    },

    D {
        @Override
        public State next(Token word, int i) {
            if(word.hasNext()){
                if(smallAlpha.indexOf(word.read(i))!=-1){
                    return D;
                }

                if(wholeNumbers.indexOf(word.read(i))!=-1){
                    return D;
                }
            }
            return AcceptingState.Accept;
        }
    },

    E {
        @Override
        public State next(Token word, int i) {
            if(word.hasNext()){
                if(wholeNumbers.indexOf(word.read(i))!=-1){
                    return E;
                }

                if(bigAlpha.indexOf(word.read(i))!=-1){
                    return E;
                }

                if(blank.indexOf(word.read(i))!=-1){
                    return E;
                }

                if(quotation.indexOf(word.read(i))!=-1){
                    return C;
                }
            }
            return FailingState.Fail;
        }
    },

    F {
        @Override
        public State next(Token word, int i) {
            if(word.hasNext()){
                if(wholeNumbers.indexOf(word.read(i))!=-1){
                    return F;
                }
            }
            return AcceptingState.Accept;
        }
    },

    G {
        @Override
        public State next(Token word, int i) {
            if(word.hasNext()){
                if(naturalNumbers.indexOf(word.read(i))!=-1){
                    return F;
                }
            }
            return AcceptingState.Accept;
        }
    };

    public abstract State next(Token word, int i);
}

public class Automata {
    public void check(Token token){
        State s;

        int i=0;
        for(s=States.A; !(s instanceof FinalState); s = s.next(token, i)){
            i++;
        }
        System.out.println(s);
    }
}
